= All Pairs- and Single Source - Shortest Path

A _Single Source Shortest Path_ algorithms calculates a path between a pair of nodes whose summed weights are minimal. A common algorithm used is Dijkstra. 

_All Pairs Shortest Path_ on the other hand calculates a shortest path forest containing all paths between the nodes in the graph. An algorithm to solve this is Floyd Warshall or Parallel Johnson's algorithm. 

== History, Explanation

Path finding, in particular searching in a maze, belongs to the classical graph problems, and the classical references are Wiener [1873], Lucas [1882] (describing a method due to C.P. Tr´emaux), and Tarry [1895] – see Biggs, Lloyd, and Wilson [1976]. 
They form the basis for depth-first search techniques.
Path problems were also studied at the beginning of the 1950’s in the context of ‘alternate routing’, that is, finding a second shortest route if the shortest route is blocked. 
This applies to freeway usage (Trueblood [1952]), but also to telephone call routing. 
At that time making long-distance calls in the U.S.A. was automatized, and alternate routes for telephone calls over the U.S. telephone network nation-wide should be found automatically.

== When to use it / use-cases

== Constraints / when not to use it

== Algorithm explanation on simple sample graph

[source,cypher]
----
MATCH (start:Node{type:'start'}), (end:Node{type:'end'})
CALL algo.shortestPath.stream(start, end, 'cost') 
YIELD nodeId, cost
                       
----


[source,cypher]
----
MATCH (start:Node{type:'start'}), (end:Node{type:'end'})
CALL algo.shortestPath(start, end, 'cost') 
YIELD loadDuration, evalDuration, nodeCount, totalCost

----

[source,cypher]
----
MATCH(n:Node {name:'s'}) WITH n CALL algo.deltaStepping.stream(n, 'cost', 3.0)
YIELD nodeId, distance RETURN nodeId, distance

----

[source,cypher]
----

MATCH(n:Node {name:'s'}) WITH n CALL algo.deltaStepping(n, 'cost', 3.0, {write:true, writeProperty:'sp'})
YIELD nodeCount, loadDuration, evalDuration, writeDuration RETURN nodeCount, loadDuration, evalDuration, writeDuration

----

== Example Usage

== References

* http://www.math.uiuc.edu/documenta/vol-ismp/32_schrijver-alexander-sp.pdf

== Implementation Details

:leveloffset: +1
// copied from: https://github.com/neo4j-contrib/neo4j-graph-algorithms/issues/80

A _Single Source Shortest Path_ algorithms calculates a path between a pair of nodes whose summed weights are minimal. A common algorithm used is Dijkstra. _All Pairs Shortest Path_ on the other hand calculates a shortest path forest containing all paths between the nodes in the graph. An algorithm to solve this is Floyd Warshall or Parallel Johnson's algorithm. 

## Progress

- [x] single threaded implementation
- [x] tests
- [x] simple benchmark 
- [ ] implement procedure
- [ ] benchmark on bigger graphs
- [ ] parallelization
- [ ] evaluation

## Requirements

`(Outgoing)RelationshipIterator` & `Weights`

## Data structured involved

- An int-based Fibonacci Heap which implements an efficient priority queue. 
- Different Container for Costs / visited state / paths

## ToDo

### benchmark

Implement benchmark on big graph

### parallelization

Parallizing _All Pairs Shortest Path_ might be easy using Dijkstra on each thread for a different node. An easy approach for _Single Source SP_ may use two threads. One starting at the start-node, one at the end-node. The first wins. [More](https://www.cs.rice.edu/~vs3/comp422/lecture-notes/comp422-lec24-s08-v2.pdf)

### evaluation

- Performance tests on different dataset sizes / level of concurrency