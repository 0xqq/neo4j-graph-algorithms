[[algorithms-similarity-jaccard]]
= The Jaccard Similarity algorithm

[abstract]
--
This section describes the Jaccard Similarity algorithm in the Neo4j Graph Algorithms library.
--

// tag::introduction[]
<intro text>
// end::introduction[]


[[algorithms-similarity-jaccard-context]]
== History and explanation

// tag::explanation[]

all the text

It is calculated using the following formula:

```
J(A,B) = ∣A ∩ B∣ / ∣(A ∪ B)∣
       = ∣A ∩ B∣ / ∣A∣ + ∣B∣ - ∣A ∩ B|
```

// end::explanation[]


[[algorithms-similarity-jaccard-usecase]]
== Use-cases - when to use the Jaccard Similarity algorithm

// tag::use-case[]
* one
* two
* threee
// end::use-case[]


[[algorithms-similarity-jaccard-sample]]
== Jaccard algorithm sample

.The following will return the Jaccard similarity of two lists of numbers
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=function]
----

// tag::function[]
.Results
[opts="header",cols="1"]
|===
| similarity
| 0.4
|===
// end::function[]

// tag::function-explanation[]
These two lists of numbers have a Jaccard similarity of 0.4.
We can see how this result is derived by breaking down the formula:

```
J(A,B) = ∣A ∩ B∣ / ∣A∣ + ∣B∣ - ∣A ∩ B|
J(A,B) = 2 / 3 + 4 - 2
       = 2 / 5
       = 0.4
```
// end::function-explanation[]



.The following will create a sample graph:
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=create-sample-graph]
----

.The following will return a stream of node pairs along with their intersection and Jaccard similarities
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=stream]
----

// tag::stream[]
.Results
[opts="header",cols="1,1,1"]
|===
| nodeA   | nodeB   | nodeC
| Will    | Michael | Chris
| Will    | Mark    | Michael
| Michael | Karin   | Chris
|===
// end::stream[]

// tag::stream-explanation[]
We can see that there are `KNOWS` triangles containing "Will, Michael, and Chris", "Will, Mark, and Michael", and "Michael, Karin, and Chris".
This means that everybody in the triangle knows each other.
// end::stream-explanation[]

.The following will count the number of triangles that a node is member of, and write it back. It will return the total triangle count and average clustering coefficient of the given graph:
[source, cypher]
----
include::scripts/triangle-count.cypher[tag=triangle-write-sample-graph]
----

.The following will count the number of triangles that a node is member of, and return a stream with `nodeId` and `triangleCount`:
[source, cypher]
----
include::scripts/triangle-count.cypher[tag=triangle-stream-sample-graph]
----

// tag::triangle-stream-sample-graph-result[]
.Results
[opts="header",cols="1,1,1"]
|===
| Name    | Triangles | Coefficient
| Karin   | 1         | 1
| Mark    | 1         | 1
| Chris   | 2         | 0.6666666666666666
| Will    | 2         | 0.6666666666666666
| Michael | 3         | 0.3
| Alice   | 0         | 0
|===
// end::triangle-stream-sample-graph-result[]

// tag::triangle-stream-sample-graph-explanation[]
We learn that Michael is part of the most triangles, but it's Karin and Mark who are the best at introducing their friends - all of the people who know them, know each other!
// end::triangle-stream-sample-graph-explanation[]


.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name         | Type   | Default        | Optional | Description
| label        | string | null           | yes      | The label to load from the graph. If null, load all nodes
| relationship | string | null           | yes      | The relationship-type to load from the graph. If null, load all nodes
| concurrency  | int    | available CPUs | yes      | The number of concurrent threads
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name  | Type | Description
| nodeA | int  | The ID of node in the given triangle
| nodeB | int  | The ID of node in the given triangle
| nodeC | int  | The ID of node in the given triangle
|===
