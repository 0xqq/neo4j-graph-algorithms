[[algorithms-similarity-jaccard]]
= The Jaccard Similarity algorithm

[abstract]
--
This section describes the Jaccard Similarity algorithm in the Neo4j Graph Algorithms library.
--

// tag::introduction[]
<intro text>
// end::introduction[]


[[algorithms-similarity-jaccard-context]]
== History and explanation

// tag::explanation[]

all the text

It is calculated using the following formula:

```
J(A,B) = ∣A ∩ B∣ / ∣(A ∪ B)∣
       = ∣A ∩ B∣ / ∣A∣ + ∣B∣ - ∣A ∩ B|
```

// end::explanation[]


[[algorithms-similarity-jaccard-usecase]]
== Use-cases - when to use the Jaccard Similarity algorithm

// tag::use-case[]
* one
* two
* threee
// end::use-case[]


[[algorithms-similarity-jaccard-sample]]
== Jaccard algorithm sample

.The following will return the Jaccard similarity of two lists of numbers
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=function]
----

// tag::function[]
.Results
[opts="header",cols="1"]
|===
| similarity
| 0.4
|===
// end::function[]

// tag::function-explanation[]
These two lists of numbers have a Jaccard similarity of 0.4.
We can see how this result is derived by breaking down the formula:

```
J(A,B) = ∣A ∩ B∣ / ∣A∣ + ∣B∣ - ∣A ∩ B|
J(A,B) = 2 / 3 + 4 - 2
       = 2 / 5
       = 0.4
```
// end::function-explanation[]


.The following will create a sample graph:
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=create-sample-graph]
----

.The following will return a stream of node pairs along with their intersection and Jaccard similarities
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=stream]
----

// tag::stream[]
.Results
[opts="header",cols="1,1,1,1"]
|===
| from     | to       | intersection | similarity
| Arya     | Karin    | 2            | 0.66
| Zhen     | Michael  | 1            | 0.66
| Zhen     | Praveena | 1            | 0.33
| Michael  | Karin    | 1            | 0.25
| Praveena | Michael  | 1            | 0.25
| Praveena | Arya     | 1            | 0.25
| Michael  | Arya     | 1            | 0.2
| Praveena | Karin    | 0            | 0
| Zhen     | Arya     | 0            | 0
| Zhen     | Karin    | 0            | 0
|===
// end::stream[]

Arya and Karin have the most similar food preferences, with two overlapping cuisines for a similarity of 0.66.
We also have 4 pairs of users who are not similar at all.
We'd probably want to filter those out, which we can do by passing in the `similarityCutoff` parameter.

.The following will return a stream of node pairs that have a similarity of at least 0.1 along with their intersection and Jaccard similarities
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=stream-similarity-cutoff]
----

// tag::stream-similarity-cutoff[]
.Results
[opts="header",cols="1,1,1,1"]
|===
| from     | to       | intersection | similarity
| Arya     | Karin    | 2            | 0.66
| Zhen     | Michael  | 1            | 0.66
| Zhen     | Praveena | 1            | 0.33
| Michael  | Karin    | 1            | 0.25
| Praveena | Michael  | 1            | 0.25
| Praveena | Arya     | 1            | 0.25
| Michael  | Arya     | 1            | 0.2
|===
// end::stream-similarity-cutoff[]

We can see that those users with no similarity have been filtered out.
If we're implementing a k-Nearest Neighbors type query we might instead want to find the most similar `k` users for a given user.
We can do that by passing in the `topK` parameter

.The following will return a stream of users along with the most similar user to them
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=stream-topk]
----

// tag::stream-topk[]
.Results
[opts="header",cols="1,1,1"]
|===
| from     | to       | similarity
| Arya     | Karin    | 0.66
| Karin    | Arya     | 0.33
| Michael  | Zhen     | 0.66
| Praveena | Zhen     | 0.33
| Zhen     | Michael  | 0.66
|===
// end::stream-topk[]

These results will not be symmetrical.
For example, the person most similar to Praveena is Zhen, but the person most similar to Zhen is actually Michael.

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name             | Type   | Default        | Optional | Description
| data             | list   | null           | no       | A list of maps of the following structure: `{source: nodeId, targets: [nodeId, nodeId, nodeId]}`
| top              | int    | 0              | yes      | The number of similar pairs to return. If `0` it will return as many as it finds.
| topK             | int    | 0              | yes      | The number of similar values to return per node. If `0` will return as many as it finds.
| similarityCutoff | int    | -1             | yes      | The threshold for Jaccard similarity. Values below this will not be returned.
| degreeCutoff     | int    | 0              | yes      | The threshold for the number of items in the `targets` list. If the list contains less than this amount that node will be excluded from the calculation.
| concurrency      | int    | available CPUs | yes      | The number of concurrent threads
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name         | Type | Description
| source1      | int  | The ID of one node in the similarity pair
| source2      | int  | The ID of other node in the similarity pair
| count1       | int  | The size of the `targets` list of one node
| count2       | int  | The size of the `targets` list of other node
| intersection | int  | The number of intersecting values in the two nodes `targets` lists
| similarity   | int  | The Jaccard similarity of the two nodes
|===
