[[algorithms-similarity-jaccard]]
= The Jaccard Similarity algorithm

[abstract]
--
This section describes the Jaccard Similarity algorithm in the Neo4j Graph Algorithms library.
--

// tag::introduction[]
<intro text>
// end::introduction[]


[[algorithms-similarity-jaccard-context]]
== History and explanation

// tag::explanation[]

all the text

It is calculated using the following formula:

```
J(A,B) = ∣A ∩ B∣ / ∣(A ∪ B)∣
       = ∣A ∩ B∣ / ∣A∣ + ∣B∣ - ∣A ∩ B|
```

// end::explanation[]


[[algorithms-similarity-jaccard-usecase]]
== Use-cases - when to use the Jaccard Similarity algorithm

// tag::use-case[]
* one
* two
* threee
// end::use-case[]


[[algorithms-similarity-jaccard-sample]]
== Jaccard algorithm sample

.The following will return the Jaccard similarity of two lists of numbers
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=function]
----

// tag::function[]
.Results
[opts="header",cols="1"]
|===
| similarity
| 0.4
|===
// end::function[]

// tag::function-explanation[]
These two lists of numbers have a Jaccard similarity of 0.4.
We can see how this result is derived by breaking down the formula:

```
J(A,B) = ∣A ∩ B∣ / ∣A∣ + ∣B∣ - ∣A ∩ B|
J(A,B) = 2 / 3 + 4 - 2
       = 2 / 5
       = 0.4
```
// end::function-explanation[]


.The following will create a sample graph:
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=create-sample-graph]
----

.The following will return a stream of node pairs along with their intersection and Jaccard similarities
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=stream]
----

// tag::stream[]
.Results
[opts="header",cols="1,1,1,1"]
|===
| from     | to       | intersection | similarity
| Arya     | Karin    | 2            | 0.66
| Zhen     | Praveena | 1            | 0.33
| Zhen     | Michael  | 1            | 0.33
| Michael  | Karin    | 1            | 0.33
| Praveena | Arya     | 1            | 0.25
| Michael  | Arya     | 1            | 0.25
| Praveena | Michael  | 0            | 0
| Praveena | Karin    | 0            | 0
| Zhen     | Arya     | 0            | 0
| Zhen     | Karin    | 0            | 0
|===
// end::stream[]

Arya and Karin have the most similar food preferences, with two overlapping cuisines for a similarity of 0.66.
We also have 4 pairs of users who are not similar at all.
We'd probably want to filter those out, which we can do by passing in the `similarityCutoff` parameter.

.The following will return a stream of node pairs that have a similarity of at least 0.1 along with their intersection and Jaccard similarities
[source, cypher]
----
include::scripts/similarity-jaccard.cypher[tag=stream-similarity-cutoff]
----

// tag::stream-similarity-cutoff[]
.Results
[opts="header",cols="1,1,1,1"]
|===
| from     | to       | intersection | similarity
| Arya     | Karin    | 2            | 0.66
| Zhen     | Praveena | 1            | 0.33
| Zhen     | Michael  | 1            | 0.33
| Michael  | Karin    | 1            | 0.33
| Praveena | Arya     | 1            | 0.25
| Michael  | Arya     | 1            | 0.25
|===
// end::stream-similarity-cutoff[]

We can see that those users with no similarity have been filtered out.
If we're implementing a k-Nearest Neighbors type query we might instead want to find the most similar `k` users for a given user.
We can do that by passing in the `topK` parameter

.The following will return a stream of pairs containing the most similar user
[source, cypher]
----
include::scripts/triangle-count.cypher[tag=triangle-write-sample-graph]
----

.The following will count the number of triangles that a node is member of, and return a stream with `nodeId` and `triangleCount`:
[source, cypher]
----
include::scripts/triangle-count.cypher[tag=triangle-stream-sample-graph]
----

// tag::triangle-stream-sample-graph-result[]
.Results
[opts="header",cols="1,1,1"]
|===
| Name    | Triangles | Coefficient
| Karin   | 1         | 1
| Mark    | 1         | 1
| Chris   | 2         | 0.6666666666666666
| Will    | 2         | 0.6666666666666666
| Michael | 3         | 0.3
| Alice   | 0         | 0
|===
// end::triangle-stream-sample-graph-result[]

// tag::triangle-stream-sample-graph-explanation[]
We learn that Michael is part of the most triangles, but it's Karin and Mark who are the best at introducing their friends - all of the people who know them, know each other!
// end::triangle-stream-sample-graph-explanation[]


.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name         | Type   | Default        | Optional | Description
| label        | string | null           | yes      | The label to load from the graph. If null, load all nodes
| relationship | string | null           | yes      | The relationship-type to load from the graph. If null, load all nodes
| concurrency  | int    | available CPUs | yes      | The number of concurrent threads
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name  | Type | Description
| nodeA | int  | The ID of node in the given triangle
| nodeB | int  | The ID of node in the given triangle
| nodeC | int  | The ID of node in the given triangle
|===
